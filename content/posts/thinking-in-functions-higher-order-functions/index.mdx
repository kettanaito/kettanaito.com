---
id: 35db4a2a-0750-4699-a405-3996a6d99a99
date: 2021-01-10
category: Engineering
title: 'Thinking in Functions, Part II: Higher-order functions'
description: Understanding and applying higher-order functions is the essential skill of any software engineer. Let's take a dive into what "higher-order" functions are, how and when to use them, and what problems they solve.
image: ./thumbnail.jpg
---

In the [previous article](/blog/thinking-in-functions) we have covered the importance and usefulness of the "input/output" pattern when writing functions. Today I'd like to continue the topic and talk about one of the most powerful concepts of functional programming—higher-order function.

---

## Higher-order function

A _higher order function_ is a function that accepts another function as an argument or returns a function. Or both.

Here's an example of a higher-order function:

```js
// Function `fn` accepts function `a` as an argument,
function fn(a) {
  // ...and calls it with `x` to get the value of `y`.
  const y = a(x)
}
```

While that example is rather abstract, there are other illustrations of higher-order functions that you may already be using on a daily basis. In JavaScript, a lot of prototype methods of native classes are higher-order functions. Such methods include:

- [`Array.prototype.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [`String.prototype.replace`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace)
- [`Array.prototype.reduce`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

All those functions accept another function as an argument and that makes them higher-order functions. Let's analyze what that means taking `Array.prototype.map` as an example:

```js
const numbers = [1, 2, 3]

// Go through each number in the `numbers` array
// and multiple it by 2.
numbers.map((number) => number * 2) // [2, 4, 6]
```

You are familiar that the `map` function goes through each array member and executes some logic on it. While it iterates over the array members without us explicitly instructing how (the way we would do with a `for` loop), the `map` function delegates what logic to execute to us by accepting a mapping function as an argument. That way it separates its concerns: iteration is hidden away, but the mapping logic gets exposed publicly and is defined upon usage.

<Quote>
  Higher-order functions encapsulate certain behavior, delegating the other
  behavior to the function they accept as an argument.
</Quote>

The contract a higher-order function establishes is true on the given terms:

- A higher-order function controls when to call a passed function;
- A higher-order function controls what arguments are to the accepted function.

Both those requirements derive from the fact that higher-order functions accept a _function definition_, in other words: instruction for the action. The given function definition is accessed by the higher-order function as an argument, making it in charge of when and how to call a given function.

To better understand this concept, let's build our own `map` function.

```js focusedLines=8-10
function map(arr, mapFn) {
  let result = []

  for (let i = 0; i < arr.length; i++) {
    // Get the current array member by index.
    const member = arr[i]

    // Call the `mapFn` function we accept as an argument,
    // and provide the current array member to it.
    const mappedValue = mapFn(member)

    // Push the result of the `mapFn` function
    // into the end array of transformed members.
    result.push(mappedValue)
  }

  return result
}
```

Our custom `map` function can be used like so:

```js
map([1, 2, 3], (number) => number * 2)
// Identical to:
// [1, 2, 3].map((number) => number * 2)
```

You can see that the iteration details like the `for` cycle and the internal `results` array are not exposed to the `mapFn` function, and our custom `map` function controls precisely when to call the given `mapFn` argument and what data to provide it:

```js lineNumberStart=10
const mappedValue = mapFn(member)
```

<Quote>
  Higher-order functions control when and how to call an argument function.
</Quote>

The point of our `map` function is that it can do much more than the multiplication of numbers. In fact, as it accepts a function that controls what to do with each array member, I dare say our `map` function can do _anything_.

```js showLineNumbers=false
map(['hello', 'world'], (word) => word.toUpperCase())
// ["HELLO", "WORLD"]
```

The power of higher-order functions goes beyond transforming array members. It's more about delegating an action (i.e. `(number) => number * 2`) to a different execution context.

### Returning a function

A higher-order function may also return a function. In that case, it acts opposite: instead of being in charge over when and how to call a given function, it generates a function and makes you in charge of when and how that function is called.

Let's use the same `map` function we've written earlier, but now rewrite it to return a function:

```js focusedLines=2,4
// Instead of accepting the array straight away,
function map(mapFn) {
  // ...we return a function that accepts that array.
  return (arr) => {
    let result = []

    // ...leaving the iteration logic as-is.
    for (let i = 0; i < arr.length; i++) {
      const member = arr[i]
      const mappedValue = mapFn(member)
      result.push(mappedValue)
    }

    return result
  }
}
```

Since the `map` no longer accepts two argument but one, calling it becomes slightly different:

```js showLineNumbers=false
map((number) => number * 2)([1, 2, 3])
```

The `fn(x)(y)` call signature is not common in JavaScript. Moreover, it's rather confusing.

> **History digression:** Not a long time ago such call signature was used in [React](https://reactjs.org/) to describe higher-order components, so it may ring some distant hook-less bells.
>
> ```js showLineNumbers={false}
> export default connect(options)(MyComponent)
> ```

If you break down that `map` function call into two separate functions things will get a little more clear:

```js
// Calling `map` now returns a new function.
const multiplyByTwo = map((number) => number * 2)

// That returned function already knows it should
// multiply each array item by 2.
// Now we only call it with the actual array.
multiplyByTwo([1, 2, 3]) // [2, 4, 6]

// We can reuse the `multiplyByTwo` function
// without having to repeat what it does,
// only changing the data it gets.
multiplyByTwo([4, 5, 6]) // [8, 10, 12]
```

Our `map` function doesn't do any iteration anymore, yet it _generates_ another function that remembers what transformations it should do and returns that generated function to be called with the actual data sometime later.

This is a great illustration of logic encapsulation.

> TODO Elaborate on the HOF returning a function.

---

## Application

A higher-order function is a great instrument to use when designing functions. The point of higher-order functions is to encapsulate logic. That encapsulation serves one or multiple of these purposes:

1. Abstract implementation details in favor of declarative code.
1. Control what logic executes now and what gets delegated for later execution.

### Logic abstraction

The most basic example is when you need to repeat a certain action N amount of times. A functional abstraction can come in handy compared to a lengthy `for` loop. Of course, it would still be using the loop internally, abstracting the iteration as it matters not on the usage surface.

```js
function repeat(fn, times) {
  for (let i = 0; i < times; i++) {
    fn()
  }
}

repeat(() => console.log('Hello'), 3)
```

By moving the imperative code to the implementation details of a higher-order function, we often gain improved code readability, making our logic easier to reason about. Compare these two examples, one with imperative code and another with declarative higher-order function:

```js
const letters = ['a', 'b', 'c']
const nextLetters = []

for (let i = 0; i < letters.length; i++) {
  nextLetters.push(letters[i].toUpperCase())
}
```

```js
const letters = ['a', 'b', 'c']
const nextLetters = map(letters, (letter) => letter.toUpperCase())
```

While both snippets above convert each letter in an Array to upper case, you spend much less cognitive function to decipher that intention when reading the second code example.

<Quote>
  It's not about the amount of code, but about the code that describes
  implementation vs. the code that describes an intention.
</Quote>

It's also about reusing and composing—creating new logic by combining existing functions. Take a look at how the abstractions below give you an idea of what's happening without you peaking into how they are written:

```js
map(ids, toUserDetail)
map(users, toPosts)
reduce(posts, toTotalLikes)
```

### Execution control

Whenever a function is called its body is executed straight away, here and now. Sometimes it's beneficial to control what logic gets executed immediately and what is delegated for future use.

Let's say we have an `expensiveLogic` function that, as the name suggests, performs some CPU-heavy computations:

```js
function expensiveLogic(data) {
  // Compute the expensive data.
  return (user) => {
    // apply already computed data.
  }
}
```

```js
const transformUser = expensiveTransformation({...})

fetch('/user').then((user) => {
  transformUser(user)
})
```

### Fundamental

Higher-order functions are also fundamental to _partial application_ and _currying_—two techniques that are irreplaceable in functional programming. These may sound alien to you at the moment, but I would be glad to make you more familiar with these concepts in the next chapters of this series.

---

## Writing a higher-order function

Just as with any other function, applying the [Input/Output pattern](/blog/thinking-in-functions) is a great place to start when writing a higher-order function. With that, there are a few additional questions to ask yourself:

1. What action is being delegated to the argument function?
1. When should the argument function be called?
1. What data is provided to the argument function?
1. Does the returned data of the argument function affects the parent function?

It's crucial to establish a clear separation between the responsibilities of a higher-order function and the argument function it accepts.

> **Exercise:** Try to write your own `filter()` function: it accepts an array and a function that returns a `Boolean`. It returns a new array, with the members for which the argument function returned `true`:
>
> ```js showLineNumbers=false
> filter([1, 3, 5], (number) => number > 2) // [3, 5]
> ```
>
> Refer to the `map` function we've created in this article for help.

---

## Real-life example

While working on one of my projects, I've decided to create a custom function that would allow me to handle an [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) instance as a Promise. The intention was to make such requests declaration shorter and support the `async/await` syntax. I've started by creating a helper function:

```js
function createXHR(options) {
  const req = new XMLHttpRequest()
  req.open(options.method, options.url)

  return new Promise((resolve, reject) => {
    req.addEventListener('load', resolve)
    req.addEventListener('abort', reject)
    req.addEventListener('error', reject)
    req.send()
  })
}
```

I would then use that `createXHR` function in my tests like this:

```js
test('handles an HTTPS GET request', async () => {
  const res = await createXHR({
    method: 'GET',
    url: 'https://test.server',
  })
})
```

Thing is, I also needed to configure the request differently for various testing scenarios: set headers, send request body, or attach event listeners. To support that, I went to my `createXHR` function and extended its logic:

```js focusedLines=3,5-9,11,15
function createXHR(options) {
  const req = new XMLHttpRequest()
  req.responseType = options.responseType || 'text'

  if (options?.headers) {
    Object.entries(options.headers).forEach([header, value] => {
      req.setRequestHeader(header, value)
    })
  }

  req.addEventListener('error', options.onError)

  return new Promise((resolve, reject) => {
    // ...
    req.send(options.body)
  })
}
```

As the test scenarios grew in diversity, my `createXHR` function grew in complexity. It resulted in an overly complex function that was hard to read and even harder to use. Why did that happen?

My mistake was to assume that the `createXHR` function should configure a request on its own. Describing a request configuration as the `options` object wasn't a sound choice either, since the object is a finite data structure and cannot represent all the variety of how a request can be declared.

Instead, my helper function should have allowed for each individual call to configure a request instance it needs. And it could do that by becoming a higher-order function and accepting an action that configures a request instance as an argument.

```js focusedLines=1-2,5-6
// Accept a `middleware` function,
function createXHR(middleware) {
  const req = new XMLHttpRequest()

  // ...that configures the given `XMLHttpRequest` instance,
  middleware(req)

  // ...and still promisifies its execution.
  return new Promise((resolve, reject) => {
    req.addEventListener('loadend', resolve)
    req.addEventListener('abort', reject)
    req.addEventListener('error', reject)
  })
}
```

> The reason `XMLHttpRequest` instance is declared within the function and not accepted as an argument is because you cannot change certain options once a request has been sent.

Notice how cleaner that function becomes as it delegates the request configuration to a `middleware` function. With that, each test can provide its own way to set up a request and still receive a Promise in return.

```js focusedLines=3-5,11-13
test('submits a new blog post', async () => {
  const req = await createXHR((req) => {
    req.open('POST', '/posts')
    req.setRequestHeader('Content-Type', 'application/json')
    req.send(JSON.stringify({ title: 'Thinking in functions', part: 2 }))
  })
})

test('handles error gracefully', async () => {
  const req = await createXHR((req) => {
    req.open('GET', '/posts/thinking-in-functions')
    req.addEventListener('error', handleError)
    req.send()
  })
})
```

---

## Afterword

High-order functions may be a hard concept to grasp at first, but give it some time, apply it in practice, and the understanding will come. It's a crucial part of functional programming and a great step to start thinking in functions. I hope this article has contributed to your knowledge and you feel an extra tool in your arsenal now.

Looking forward to seeing you in the next part of the "Thinking in Functions" series!
